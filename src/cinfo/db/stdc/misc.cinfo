# $Id: misc.cinfo,v 1.6 1996/08/18 13:35:32 sandro Exp $

("Miscellaneous"

################ tables ################

("Tables"

("[keywords-table]" t="\
auto	 break	 case	 char	  const
continue default do	 double	  else
enum	 extern	 float	 for	  goto
if	 int	 long	 register return
short	 signed	 sizeof	 static	  struct
switch	 typedef union	 unsigned void
volatile while")

("[type-qualifiers-table]" t="\
const		Qualify an identifier as unmodifiable.
volatile	Qualify an identifier as frequently-modifiable.")

("[storage-classes-table]" t="\
auto		Automatic allocation.
extern		External linkage.
register	Fast access register.
static		Internal linkage.
typedef		Type.")

("[type-specifiers-table]" t="\
char
double
enum _tagname_
float
int
long
signed
short
struct _tagname_
unsigned
union _tagname_
void

Combined type specifiers
char
double
enum _tagname_
float
int, signed int
long double
long int, long, signed long, signed long int
signed char
short int, short, signed short int, signed short
struct _tagname_
typedef
unsigned char
unsigned int, unsigned
unsigned long int, unsigned long
unsigned sort int, unsigned short
union _tagname_
void")

("[preprocessor-directives-table]" t="\
#if		Includes the code if the condition is true.
#elif		Includes the code if the previous condition is false
		and the specified condition is true.
#else		Includes the code if the previous condition is false.
#endif		Closes the previous `#if' directive.

#ifdef		Includes the code if the specified macro is defined.
#ifndef		Includes the code if the specified macro is not defined.
#define		Defines the specified macro.
#undef		Undefines the specified macro.
#include	Reads another file and includes it.
#line		Reassign the line number.
#pragma		Executes an operation defined by the implementation.
#error		Prints an error message.")

("[preprocessor-predefined-macros-table]" t="\
__DATE__	Expands itself into a string that contains the date of
		the compilation in the format \"Mmm dd yyyy\".
__FILE__	Expands itself into a string that contains the current
		file name.
__LINE__	Expands itself into the current line number.
__STDC__	Expands itself, if the compiler follows the
		ANSI/ISO C standards, into the value `1'.
__TIME__	Expands itself into a string that contains the time of
		the compilation in the format \"hh:mm:ss\".")

("[trigraphs-table]" t="\
??= trigraph sequence is replaced with a `#'.
??( trigraph sequence is replaced with a `['.
??/ trigraph sequence is replaced with a `\\'.
??) trigraph sequence is replaced with a `]'.
??' trigraph sequence is replaced with a `^'.
??< trigraph sequence is replaced with a `{'.
??! trigraph sequence is replaced with a `|'.
??> trigraph sequence is replaced with a `}'.
??- trigraph sequence is replaced with a `~'.")

("[operators-table]" t="\
!	!=	%	%=	&	&&
&=	()	*	*=	+	++
+=	,	-	--	-=	->
.	/	/=	<	<<	<<=
<=	=	==	>	>=	>>
>>=	?:	[]	^	^=	|
|=	||	(type)	~	sizeof")

("[operators-precedence-table]" t="\
Operator				Associativity
-----------------------------------------------------
() [] -> .				left to right
! ~ ++ -- + - * & (type) sizeof		right to left
* / %					left to right
+ -					left to right
<< >>					left to right
< <= > >=				left to right
== !=					left to right
&					left to right
^					left to right
|					left to right
&&					left to right
||					left to right
?:					right to left
= += -= *= /= %= &= ^= |= <<= >>=	right to left
,				    	left to right

The operators +, - and * have more precedence than the respective
binary forms.")

("[ascii-table]" t="\
|000 nul|001 soh|002 stx|003 etx|004 eot|005 enq|006 ack|007 bel|
|010 bs |011 ht |012 nl |013 vt |014 np |015 cr |016 so |017 si |
|020 dle|021 dc1|022 dc2|023 dc3|024 dc4|025 nak|026 syn|027 etb|
|030 can|031 em |032 sub|033 esc|034 fs |035 gs |036 rs |037 us |
|040 sp |041  ! |042  \" |043  # |044  $ |045  % |046  & |047  ' |
|050  ( |051  ) |052  * |053  + |054  , |055  - |056  . |057  / |
|060  0 |061  1 |062  2 |063  3 |064  4 |065  5 |066  6 |067  7 |
|070  8 |071  9 |072  : |073  ; |074  < |075  = |076  > |077  ? |
|100  @ |101  A |102  B |103  C |104  D |105  E |106  F |107  G |
|110  H |111  I |112  J |113  K |114  L |115  M |116  N |117  O |
|120  P |121  Q |122  R |123  S |124  T |125  U |126  V |127  W |
|130  X |131  Y |132  Z |133  [ |134  \\ |135  ] |136  ^ |137  _ |
|140  ` |141  a |142  b |143  c |144  d |145  e |146  f |147  g |
|150  h |151  i |152  j |153  k |154  l |155  m |156  n |157  o |
|160  p |161  q |162  r |163  s |164  t |165  u |166  v |167  w |
|170  x |171  y |172  z |173  { |174  | |175  } |176  ~ |177 del|

| 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel|
| 08 bs | 09 ht | 0a nl | 0b vt | 0c np | 0d cr | 0e so | 0f si |
| 10 dle| 11 dc1| 12 dc2| 13 dc3| 14 dc4| 15 nak| 16 syn| 17 etb|
| 18 can| 19 em | 1a sub| 1b esc| 1c fs | 1d gs | 1e rs | 1f us |
| 20 sp | 21  ! | 22  \" | 23  # | 24  $ | 25  % | 26  & | 27  ' |
| 28  ( | 29  ) | 2a  * | 2b  + | 2c  , | 2d  - | 2e  . | 2f  / |
| 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |
| 38  8 | 39  9 | 3a  : | 3b  ; | 3c  < | 3d  = | 3e  > | 3f  ? |
| 40  @ | 41  A | 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |
| 48  H | 49  I | 4a  J | 4b  K | 4c  L | 4d  M | 4e  N | 4f  O |
| 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |
| 58  X | 59  Y | 5a  Z | 5b  [ | 5c  \\ | 5d  ] | 5e  ^ | 5f  _ |
| 60  ` | 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |
| 68  h | 69  i | 6a  j | 6b  k | 6c  l | 6d  m | 6e  n | 6f  o |
| 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
| 78  x | 79  y | 7a  z | 7b  { | 7c  | | 7d  } | 7e  ~ | 7f del|

|  0 nul|  1 soh|  2 stx|  3 etx|  4 eot|  5 enq|  6 ack|  7 bel|
|  8 bs |  9 ht | 10 nl | 11 vt | 12 np | 13 cr | 14 so | 15 si |
| 16 dle| 17 dc1| 18 dc2| 19 dc3| 20 dc4| 21 nak| 22 syn| 23 etb|
| 24 can| 25 em | 26 sub| 27 esc| 28 fs | 29 gs | 30 rs | 31 us |
| 32 sp | 33  ! | 34  \" | 35  # | 36  $ | 37  % | 38  & | 39  ' |
| 40  ( | 41  ) | 42  * | 43  + | 44  , | 45  - | 46  . | 47  / |
| 48  0 | 49  1 | 50  2 | 51  3 | 52  4 | 53  5 | 54  6 | 55  7 |
| 56  8 | 57  9 | 58  : | 59  ; | 60  < | 61  = | 62  > | 63  ? |
| 64  @ | 65  A | 66  B | 67  C | 68  D | 69  E | 70  F | 71  G |
| 72  H | 73  I | 74  J | 75  K | 76  L | 77  M | 78  N | 79  O |
| 80  P | 81  Q | 82  R | 83  S | 84  T | 85  U | 86  V | 87  W |
| 88  X | 89  Y | 90  Z | 91  [ | 92  \\ | 93  ] | 94  ^ | 95  _ |
| 96  ` | 97  a | 98  b | 99  c |100  d |101  e |102  f |103  g |
|104  h |105  i |106  j |107  k |108  l |109  m |110  n |111  o |
|112  p |113  q |114  r |115  s |116  t |117  u |118  v |119  w |
|120  x |121  y |122  z |123  { |124  | |125  } |126  ~ |127 del|")

("[escape-sequences-table]" t="\
newline			NL(LF)		\\n
horizontal tabulation	HT		\\t
vertical tabulation	VT		\\v
backspace		BS		\\b
carriage return		CR		\\r
form feed		FF		\\f
alarm			BEL		\\a
backslash		\\		\\\\
question mark		?		\\?
aphostrophe		'		\\'
quotation marks		\"		\\\"
octal number		ooo		\\ooo
hexadecimal number	hh		\\xhh")

("[ASCII-table]" t="\
000  0	  0x00	NUL  <ctrl-@>		NULL character
001  1	  0x01	SOH  <ctrl-A>		Start of header
002  2	  0x02	STX  <ctrl-B>		Start of text
003  3	  0x03	ETX  <ctrl-C>		End of text
004  4	  0x04	EOT  <ctrl-D>		End of trasmission
005  5	  0x05	ENQ  <ctrl-E>		Enquiry
006  6	  0x06	ACK  <ctrl-F>		Positive acknowledgement
007  7	  0x07	BEL  <ctrl-G>		Alarm
010  8	  0x08	BS   <ctrl-H>		Backspace
011  9	  0x09	HT   <ctrl-I>		Horizontal tabulation
012  10	  0x0a	LF   <ctrl-J>		Line feed
013  11	  0x0b	VT   <ctrl-K>		Vertical tabulation
014  12	  0x0c	FF   <ctrl-L>		Form feed
015  13	  0x0d	CR   <ctrl-M>		Carriage return
016  14	  0x0e	SO   <ctrl-N>		Shift out
017  15	  0x0f	SI   <ctrl-O>		Shift in
020  16	  0x10	DLE  <ctrl-P>		Data link escape
021  17	  0x11	DC1  <ctrl-Q>		Device control 1 (XON)
022  18	  0x12	DC2  <ctrl-R>		Device control 2 (tape on)
023  19	  0x13	DC3  <ctrl-S>		Device control 3 (XOFF)
024  20	  0x14	DC4  <ctrl-T>		Device control 4 (tape off)
025  21	  0x15	NAK  <ctrl-U>		Negative acknoledgement
026  22	  0x16	SYN  <ctrl-V>		Syncronize
027  23	  0x17	ETB  <ctrl-W>		End of trasmission block
030  24	  0x18	CAN  <ctrl-X>		Cancel
031  25	  0x19	EM   <ctrl-Y>		End of medium
032  26	  0x1a	SUB  <ctrl-Z>		Substitute
033  27	  0x1b	ESC  <ctrl-[>		Escape
034  28	  0x1c	FS   <ctrl-\\>		Form Separator
035  29	  0x1d	GS   <ctrl-]>		Group Separator
036  30	  0x1e	RS   <ctrl-^>		Record Separator
037  31	  0x1f	US   <ctrl-_>		Unti Separator
040  32	  0x20	SP   Space
041  33	  0x21	!
042  34	  0x22	\"
043  35	  0x23	#
044  36	  0x24	$
045  37	  0x25	%
046  38	  0x26	&
047  39	  0x27	'
050  40	  0x28	(
051  41	  0x29	)
052  42	  0x2a	*
053  43	  0x2b	+
054  44	  0x2c	,
055  45	  0x2d	-
056  46	  0x2e	.
057  47	  0x2f	/
060  48	  0x30	0
061  49	  0x31	1
062  50	  0x32	2
063  51	  0x33	3
064  52	  0x34	4
065  53	  0x35	5
066  54	  0x36	6
067  55	  0x37	7
070  56	  0x38	8
071  57	  0x39	9
072  58	  0x3a	:
073  59	  0x3b	;
074  60	  0x3c	<
075  61	  0x3d	=
076  62	  0x3e	>
077  63	  0x3f	?
100  64	  0x40	@
101  65	  0x41	A
102  66	  0x42	B
103  67	  0x43	C
104  68	  0x44	D
105  69	  0x45	E
106  70	  0x46	F
107  71	  0x47	G
110  72	  0x48	H
111  73	  0x49	I
112  74	  0x4a	J
113  75	  0x4b	K
114  76	  0x4c	L
115  77	  0x4d	M
116  78	  0x4e	N
117  79	  0x4f	O
120  80	  0x50	P
121  81	  0x51	Q
122  82	  0x52	R
123  83	  0x53	S
124  84	  0x54	T
125  85	  0x55	U
126  86	  0x56	V
127  87	  0x57	W
130  88	  0x58	X
131  89	  0x59	Y
132  90	  0x5a	Z
133  91	  0x5b	[
134  92	  0x5c	\\
135  93	  0x5d	]
136  94	  0x5e	^
137  95	  0x5f	_
140  96	  0x60	`
141  97	  0x61	a
142  98	  0x62	b
143  99	  0x63	c
144  100  0x64	d
145  101  0x65	e
146  102  0x66	f
147  103  0x67	g
150  104  0x68	h
151  105  0x69	i
152  106  0x6a	j
153  107  0x6b	k
154  108  0x6c	l
155  109  0x6d	m
156  110  0x6e	n
157  111  0x6f	o
160  112  0x70	p
161  113  0x71	q
162  114  0x72	r
163  115  0x73	s
164  116  0x74	t
165  117  0x75	u
166  118  0x76	v
167  119  0x77	w
170  120  0x78	x
171  121  0x79	y
172  122  0x7a	z
173  123  0x7b	{
174  124  0x7c	|
175  125  0x7d	}
176  126  0x7e	~
177  127  0x7f	DEL			Delete")

) # "Tables"

################ grammars ################

("Grammars"

("[yacc-grammar]" t="\
%token IDENTIFIER CONSTANT STRING_LITERAL SIZEOF
%token PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP
%token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN
%token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN
%token XOR_ASSIGN OR_ASSIGN TYPE_NAME

%token TYPEDEF EXTERN STATIC AUTO REGISTER
%token VOID CHAR SHORT INT LONG FLOAT DOUBLE SIGNED UNSIGNED
%token CONST VOLATILE
%token STRUCT UNION ENUM ELLIPSIS

%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN

%start translation_unit
%%

primary_expression
	: identifier
	| CONSTANT
	| STRING_LITERAL
	| '(' expression ')'
	;

postfix_expression
	: primary_expression
	| postfix_expression '[' expression ']'
	| postfix_expression '(' ')'
	| postfix_expression '(' argument_expression_list ')'
	| postfix_expression '.' identifier
	| postfix_expression PTR_OP identifier
	| postfix_expression INC_OP
	| postfix_expression DEC_OP
	;

argument_expression_list
	: assignment_expression
	| argument_expression_list ',' assignment_expression
	;

unary_expression
	: postfix_expression
	| INC_OP unary_expression
	| DEC_OP unary_expression
	| unary_operator cast_expression
	| SIZEOF unary_expression
	| SIZEOF '(' type_name ')'
	;

unary_operator
	: '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'
	;

cast_expression
	: unary_expression
	| '(' type_name ')' cast_expression
	;

multiplicative_expression
	: cast_expression
	| multiplicative_expression '*' cast_expression
	| multiplicative_expression '/' cast_expression
	| multiplicative_expression '%' cast_expression
	;

additive_expression
	: multiplicative_expression
	| additive_expression '+' multiplicative_expression
	| additive_expression '-' multiplicative_expression
	;

shift_expression
	: additive_expression
	| shift_expression LEFT_OP additive_expression
	| shift_expression RIGHT_OP additive_expression
	;

relational_expression
	: shift_expression
	| relational_expression '<' shift_expression
	| relational_expression '>' shift_expression
	| relational_expression LE_OP shift_expression
	| relational_expression GE_OP shift_expression
	;

equality_expression
	: relational_expression
	| equality_expression EQ_OP relational_expression
	| equality_expression NE_OP relational_expression
	;

and_expression
	: equality_expression
	| and_expression '&' equality_expression
	;

exclusive_or_expression
	: and_expression
	| exclusive_or_expression '^' and_expression
	;

inclusive_or_expression
	: exclusive_or_expression
	| inclusive_or_expression '|' exclusive_or_expression
	;

logical_and_expression
	: inclusive_or_expression
	| logical_and_expression AND_OP inclusive_or_expression
	;

logical_or_expression
	: logical_and_expression
	| logical_or_expression OR_OP logical_and_expression
	;

conditional_expression
	: logical_or_expression
	| logical_or_expression '?' expression ':' conditional_expression
	;

assignment_expression
	: conditional_expression
	| unary_expression assignment_operator assignment_expression
	;

assignment_operator
	: '='
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	| LEFT_ASSIGN
	| RIGHT_ASSIGN
	| AND_ASSIGN
	| XOR_ASSIGN
	| OR_ASSIGN
	;

expression
	: assignment_expression
	| expression ',' assignment_expression
	;

constant_expression
	: conditional_expression
	;

declaration
	: declaration_specifiers ';'
	| declaration_specifiers init_declarator_list ';'
	;

declaration_specifiers
	: storage_class_specifier
	| storage_class_specifier declaration_specifiers
	| type_specifier
	| type_specifier declaration_specifiers
	| type_qualifier
	| type_qualifier declaration_specifiers
	;

init_declarator_list
	: init_declarator
	| init_declarator_list ',' init_declarator
	;

init_declarator
	: declarator
	| declarator '=' initializer
	;

storage_class_specifier
	: TYPEDEF
	| EXTERN
	| STATIC
	| AUTO
	| REGISTER
	;

type_specifier
	: VOID
	| CHAR
	| SHORT
	| INT
	| LONG
	| FLOAT
	| DOUBLE
	| SIGNED
	| UNSIGNED
	| struct_or_union_specifier
	| enum_specifier
	| TYPE_NAME
	;

struct_or_union_specifier
	: struct_or_union identifier '{' struct_declaration_list '}'
	| struct_or_union '{' struct_declaration_list '}'
	| struct_or_union identifier
	;

struct_or_union
	: STRUCT
	| UNION
	;

struct_declaration_list
	: struct_declaration
	| struct_declaration_list struct_declaration
	;

struct_declaration
	: specifier_qualifier_list struct_declarator_list ';'
	;

specifier_qualifier_list
	: type_specifier specifier_qualifier_list
	| type_specifier
	| type_qualifier specifier_qualifier_list
	| type_qualifier
	;

struct_declarator_list
	: struct_declarator
	| struct_declarator_list ',' struct_declarator
	;

struct_declarator
	: declarator
	| ':' constant_expression
	| declarator ':' constant_expression
	;

enum_specifier
	: ENUM '{' enumerator_list '}'
	| ENUM identifier '{' enumerator_list '}'
	| ENUM identifier
	;

enumerator_list
	: enumerator
	| enumerator_list ',' enumerator
	;

enumerator
	: identifier
	| identifier '=' constant_expression
	;

type_qualifier
	: CONST
	| VOLATILE
	;

declarator
	: pointer direct_declarator
	| direct_declarator
	;

direct_declarator
	: identifier
	| '(' declarator ')'
	| direct_declarator '[' constant_expression ']'
	| direct_declarator '[' ']'
	| direct_declarator '(' parameter_type_list ')'
	| direct_declarator '(' identifier_list ')'
	| direct_declarator '(' ')'
	;

pointer
	: '*'
	| '*' type_qualifier_list
	| '*' pointer
	| '*' type_qualifier_list pointer
	;

type_qualifier_list
	: type_qualifier
	| type_qualifier_list type_qualifier
	;


parameter_type_list
	: parameter_list
	| parameter_list ',' ELLIPSIS
	;

parameter_list
	: parameter_declaration
	| parameter_list ',' parameter_declaration
	;

parameter_declaration
	: declaration_specifiers declarator
	| declaration_specifiers abstract_declarator
	| declaration_specifiers
	;

identifier_list
	: identifier
	| identifier_list ',' identifier
	;

type_name
	: specifier_qualifier_list
	| specifier_qualifier_list abstract_declarator
	;

abstract_declarator
	: pointer
	| direct_abstract_declarator
	| pointer direct_abstract_declarator
	;

direct_abstract_declarator
	: '(' abstract_declarator ')'
	| '[' ']'
	| '[' constant_expression ']'
	| direct_abstract_declarator '[' ']'
	| direct_abstract_declarator '[' constant_expression ']'
	| '(' ')'
	| '(' parameter_type_list ')'
	| direct_abstract_declarator '(' ')'
	| direct_abstract_declarator '(' parameter_type_list ')'
	;

initializer
	: assignment_expression
	| '{' initializer_list '}'
	| '{' initializer_list ',' '}'
	;

initializer_list
	: initializer
	| initializer_list ',' initializer
	;

statement
	: labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;

labeled_statement
	: identifier ':' statement
	| CASE constant_expression ':' statement
	| DEFAULT ':' statement
	;

compound_statement
	: '{' '}'
	| '{' statement_list '}'
	| '{' declaration_list '}'
	| '{' declaration_list statement_list '}'
	;

declaration_list
	: declaration
	| declaration_list declaration
	;

statement_list
	: statement
	| statement_list statement
	;

expression_statement
	: ';'
	| expression ';'
	;

selection_statement
	: IF '(' expression ')' statement
	| IF '(' expression ')' statement ELSE statement
	| SWITCH '(' expression ')' statement
	;

iteration_statement
	: WHILE '(' expression ')' statement
	| DO statement WHILE '(' expression ')' ';'
	| FOR '(' expression_statement expression_statement ')' statement
	| FOR '(' expression_statement expression_statement expression ')' statement
	;

jump_statement
	: GOTO identifier ';'
	| CONTINUE ';'
	| BREAK ';'
	| RETURN ';'
	| RETURN expression ';'
	;

translation_unit
	: external_declaration
	| translation_unit external_declaration
	;

external_declaration
	: function_definition
	| declaration
	;

function_definition
	: declaration_specifiers declarator declaration_list compound_statement
	| declaration_specifiers declarator compound_statement
	| declarator declaration_list compound_statement
	| declarator compound_statement
	;

identifier:
	IDENTIFIER
	;

%%")

("[bnf-grammar]" t="\
The terminal tokens defined in the grammar:
IDENTIFIER, CONSTANT, STRING_LITERAL, SIZEOF, PTR_OP, INC_OP, DEC_OP,
LEFT_OP, RIGHT_OP, LE_OP, GE_OP, EQ_OP, NE_OP, AND_OP, OR_OP, MUL_ASSIGN,
DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN, SUB_ASSIGN, LEFT_ASSIGN, RIGHT_ASSIGN,
AND_ASSIGN, XOR_ASSIGN, OR_ASSIGN, TYPE_NAME, TYPEDEF, EXTERN, STATIC, AUTO,
REGISTER, CHAR, SHORT, INT, LONG, SIGNED, UNSIGNED, FLOAT, DOUBLE, CONST,
VOLATILE, VOID, STRUCT, UNION, ENUM, ELLIPSIS, CASE, DEFAULT, IF, ELSE,
SWITCH, WHILE, DO, FOR, GOTO, CONTINUE, BREAK, RETURN

<primary_expression> ::= <identifier> 
                         | <CONSTANT> 
                         | <STRING_LITERAL> 
                         | '(' <expression> ')' 

<postfix_expression> ::= <primary_expression> 
                         | <postfix_expression> '[' <expression> ']' 
                         | <postfix_expression> '(' ')' 
                         | <postfix_expression> '(' <argument_expression_list> ')' 
                         | <postfix_expression> '.' <identifier> 
                         | <postfix_expression> <PTR_OP> <identifier> 
                         | <postfix_expression> <INC_OP> 
                         | <postfix_expression> <DEC_OP> 

<argument_expression_list> ::= <assignment_expression> 
                               | <argument_expression_list> ',' <assignment_expression> 

<unary_expression> ::= <postfix_expression> 
                       | <INC_OP> <unary_expression> 
                       | <DEC_OP> <unary_expression> 
                       | <unary_operator> <cast_expression> 
                       | <SIZEOF> <unary_expression> 
                       | <SIZEOF> '(' <type_name> ')' 

<unary_operator> ::= '&' 
                     | '*' 
                     | '+' 
                     | '-' 
                     | '~' 
                     | '!' 

<cast_expression> ::= <unary_expression> 
                      | '(' <type_name> ')' <cast_expression> 

<multiplicative_expression> ::= <cast_expression> 
                                | <multiplicative_expression> '*' <cast_expression> 
                                | <multiplicative_expression> '/' <cast_expression> 
                                | <multiplicative_expression> '%' <cast_expression> 

<additive_expression> ::= <multiplicative_expression> 
                          | <additive_expression> '+' <multiplicative_expression> 
                          | <additive_expression> '-' <multiplicative_expression> 

<shift_expression> ::= <additive_expression> 
                       | <shift_expression> <LEFT_OP> <additive_expression> 
                       | <shift_expression> <RIGHT_OP> <additive_expression> 

<relational_expression> ::= <shift_expression> 
                            | <relational_expression> '<' <shift_expression> 
                            | <relational_expression> '>' <shift_expression> 
                            | <relational_expression> <LE_OP> <shift_expression> 
                            | <relational_expression> <GE_OP> <shift_expression> 

<equality_expression> ::= <relational_expression> 
                          | <equality_expression> <EQ_OP> <relational_expression> 
                          | <equality_expression> <NE_OP> <relational_expression> 

<and_expression> ::= <equality_expression> 
                     | <and_expression> '&' <equality_expression> 

<exclusive_or_expression> ::= <and_expression> 
                              | <exclusive_or_expression> '^' <and_expression> 

<inclusive_or_expression> ::= <exclusive_or_expression> 
                              | <inclusive_or_expression> '|' <exclusive_or_expression> 

<logical_and_expression> ::= <inclusive_or_expression> 
                             | <logical_and_expression> <AND_OP> <inclusive_or_expression> 

<logical_or_expression> ::= <logical_and_expression> 
                            | <logical_or_expression> <OR_OP> <logical_and_expression> 

<conditional_expression> ::= <logical_or_expression> 
                             | <logical_or_expression> '?' <expression> ':' <conditional_expression> 

<assignment_expression> ::= <conditional_expression> 
                            | <unary_expression> <assignment_operator> <assignment_expression> 

<assignment_operator> ::= '=' 
                          | <MUL_ASSIGN> 
                          | <DIV_ASSIGN> 
                          | <MOD_ASSIGN> 
                          | <ADD_ASSIGN> 
                          | <SUB_ASSIGN> 
                          | <LEFT_ASSIGN> 
                          | <RIGHT_ASSIGN> 
                          | <AND_ASSIGN> 
                          | <XOR_ASSIGN> 
                          | <OR_ASSIGN> 

<expression> ::= <assignment_expression> 
                 | <expression> ',' <assignment_expression> 

<constant_expression> ::= <conditional_expression> 

<declaration> ::= <declaration_specifiers> ';' 
                  | <declaration_specifiers> <init_declarator_list> ';' 

<declaration_specifiers> ::= <storage_class_specifier> 
                             | <storage_class_specifier> <declaration_specifiers> 
                             | <type_specifier> 
                             | <type_specifier> <declaration_specifiers> 
                             | <type_qualifier> 
                             | <type_qualifier> <declaration_specifiers> 

<init_declarator_list> ::= <init_declarator> 
                           | <init_declarator_list> ',' <init_declarator> 

<init_declarator> ::= <declarator> 
                      | <declarator> '=' <initializer> 

<storage_class_specifier> ::= <TYPEDEF> 
                              | <EXTERN> 
                              | <STATIC> 
                              | <AUTO> 
                              | <REGISTER> 

<type_specifier> ::= <VOID> 
                     | <CHAR> 
                     | <SHORT> 
                     | <INT> 
                     | <LONG> 
                     | <FLOAT> 
                     | <DOUBLE> 
                     | <SIGNED> 
                     | <UNSIGNED> 
                     | <struct_or_union_specifier> 
                     | <enum_specifier> 
                     | <TYPE_NAME> 

<struct_or_union_specifier> ::= <struct_or_union> <identifier> '{' <struct_declaration_list> '}' 
                                | <struct_or_union> '{' <struct_declaration_list> '}' 
                                | <struct_or_union> <identifier> 

<struct_or_union> ::= <STRUCT> 
                      | <UNION> 

<struct_declaration_list> ::= <struct_declaration> 
                              | <struct_declaration_list> <struct_declaration> 

<struct_declaration> ::= <specifier_qualifier_list> <struct_declarator_list> ';' 

<specifier_qualifier_list> ::= <type_specifier> <specifier_qualifier_list> 
                               | <type_specifier> 
                               | <type_qualifier> <specifier_qualifier_list> 
                               | <type_qualifier> 

<struct_declarator_list> ::= <struct_declarator> 
                             | <struct_declarator_list> ',' <struct_declarator> 

<struct_declarator> ::= <declarator> 
                        | ':' <constant_expression> 
                        | <declarator> ':' <constant_expression> 

<enum_specifier> ::= <ENUM> '{' <enumerator_list> '}' 
                     | <ENUM> <identifier> '{' <enumerator_list> '}' 
                     | <ENUM> <identifier> 

<enumerator_list> ::= <enumerator> 
                      | <enumerator_list> ',' <enumerator> 

<enumerator> ::= <identifier> 
                 | <identifier> '=' <constant_expression> 

<type_qualifier> ::= <CONST> 
                     | <VOLATILE> 

<declarator> ::= <pointer> <direct_declarator> 
                 | <direct_declarator> 

<direct_declarator> ::= <identifier> 
                        | '(' <declarator> ')' 
                        | <direct_declarator> '[' <constant_expression> ']' 
                        | <direct_declarator> '[' ']' 
                        | <direct_declarator> '(' <parameter_type_list> ')' 
                        | <direct_declarator> '(' <identifier_list> ')' 
                        | <direct_declarator> '(' ')' 

<pointer> ::= '*' 
              | '*' <type_qualifier_list> 
              | '*' <pointer> 
              | '*' <type_qualifier_list> <pointer> 

<type_qualifier_list> ::= <type_qualifier> 
                          | <type_qualifier_list> <type_qualifier> 

<parameter_type_list> ::= <parameter_list> 
                          | <parameter_list> ',' <ELLIPSIS> 

<parameter_list> ::= <parameter_declaration> 
                     | <parameter_list> ',' <parameter_declaration> 

<parameter_declaration> ::= <declaration_specifiers> <declarator> 
                            | <declaration_specifiers> <abstract_declarator> 
                            | <declaration_specifiers> 

<identifier_list> ::= <identifier> 
                      | <identifier_list> ',' <identifier> 

<type_name> ::= <specifier_qualifier_list> 
                | <specifier_qualifier_list> <abstract_declarator> 

<abstract_declarator> ::= <pointer> 
                          | <direct_abstract_declarator> 
                          | <pointer> <direct_abstract_declarator> 

<direct_abstract_declarator> ::= '(' <abstract_declarator> ')' 
                                 | '[' ']' 
                                 | '[' <constant_expression> ']' 
                                 | <direct_abstract_declarator> '[' ']' 
                                 | <direct_abstract_declarator> '[' <constant_expression> ']' 
                                 | '(' ')' 
                                 | '(' <parameter_type_list> ')' 
                                 | <direct_abstract_declarator> '(' ')' 
                                 | <direct_abstract_declarator> '(' <parameter_type_list> ')' 

<initializer> ::= <assignment_expression> 
                  | '{' <initializer_list> '}' 
                  | '{' <initializer_list> ',' '}' 

<initializer_list> ::= <initializer> 
                       | <initializer_list> ',' <initializer> 

<statement> ::= <labeled_statement> 
                | <compound_statement> 
                | <expression_statement> 
                | <selection_statement> 
                | <iteration_statement> 
                | <jump_statement> 

<labeled_statement> ::= <identifier> ':' <statement> 
                        | <CASE> <constant_expression> ':' <statement> 
                        | <DEFAULT> ':' <statement> 

<compound_statement> ::= '{' '}' 
                         | '{' <statement_list> '}' 
                         | '{' <declaration_list> '}' 
                         | '{' <declaration_list> <statement_list> '}' 

<declaration_list> ::= <declaration> 
                       | <declaration_list> <declaration> 

<statement_list> ::= <statement> 
                     | <statement_list> <statement> 

<expression_statement> ::= ';' 
                           | <expression> ';' 

<selection_statement> ::= <IF> '(' <expression> ')' <statement> 
                          | <IF> '(' <expression> ')' <statement> <ELSE> <statement> 
                          | <SWITCH> '(' <expression> ')' <statement> 

<iteration_statement> ::= <WHILE> '(' <expression> ')' <statement> 
                          | <DO> <statement> <WHILE> '(' <expression> ')' ';' 
                          | <FOR> '(' <expression_statement> <expression_statement> ')' <statement> 
                          | <FOR> '(' <expression_statement> <expression_statement> <expression> ')' <statement> 

<jump_statement> ::= <GOTO> <identifier> ';' 
                     | <CONTINUE> ';' 
                     | <BREAK> ';' 
                     | <RETURN> ';' 
                     | <RETURN> <expression> ';' 

<translation_unit> ::= <external_declaration> 
                       | <translation_unit> <external_declaration> 

<external_declaration> ::= <function_definition> 
                           | <declaration> 

<function_definition> ::= <declaration_specifiers> <declarator> <declaration_list> <compound_statement> 
                          | <declaration_specifiers> <declarator> <compound_statement> 
                          | <declarator> <declaration_list> <compound_statement> 
                          | <declarator> <compound_statement> 

<identifier> ::= <IDENTIFIER>")

) # "Grammars"

) # "Miscellaneous"
